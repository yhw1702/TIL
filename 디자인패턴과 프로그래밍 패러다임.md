# TIL

>오늘 배운 것을 기록합니다.

# 디자인패턴과 프로그래밍 패러다임

<details>
  <summary>2022-11-04 (디자인패턴)</summary>
<pre>

# 1. 디자인 패턴
프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의
'규약'형태로 만들어 놓은 것을 의미합니다.

## 1-1 싱글톤 패턴(Singleton pattern)
하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴입니다. 보통 데이터베이스 연결 모듈에 많이
사용합니다. 이처럼 동일한 자원이나 데이터를 처리하는 객체가 불필요하게 여러 개 만들어질 필요가
없는 경우에 주로 사용합니다.

![image](https://user-images.githubusercontent.com/105253684/200205493-333887ea-bdc2-453e-a0a5-1a1e65646208.png)

### 1-1-1 싱글톤 패턴의 단점
TDD(Test Driven Development)를 할 때 걸림돌이 됩니다. TDD를 할 때 단위 테스트를 주로 하는데,
단위 테스트는 테스트가 서로 독립적이어야 하며 테스트를 어떤 순서로든 실행할 수 있어야 합니다.

하지만 싱글톤 패턴은 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴이므로 각 테스트마다
'독립적인' 인스턴스를 만들기가 어렵습니다.

### 1-1-2 의존성 주입
싱글톤 패턴은 사용하기가 쉽고 굉장히 실용적이지만 모듈 간의 결합을 강하게 만들 수 있다는 단점이
있습니다. 이때 의존성 주입(DI, Dependency Injection)을 통해 모듈간의 결합을 조금 더 느슨하게
만들어 해결할 수 있습니다.

참고로 의존성이란 종속성이라고도 하며 A가 B에 의존성이 있다는 것은 B의 변경 사항에 대해 A또한
변해야 된다는 것을 의미합니다.

## 1-2 팩토리 패턴(Factory pattern)
객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴이자 상속 관계에 있는 두 클래스에서
상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는
패턴입니다.

![image](https://user-images.githubusercontent.com/105253684/200206347-c5d2248f-d3cb-496e-a0e9-836ff747e264.png)

## 1-3 전략 패턴(Strategy pattern)
정책 패턴(policy pattern)이라고도 하며, 객체의 행위를 바꾸고 싶은 경우 '직접' 수정하지 않고 전략
이라고 부르는 '캡슐화한 알고리즘'을 컨텍스트 안에서 바꿔주면서 상효 교체가 가능하게 만드는 패턴
입니다.

![image](https://user-images.githubusercontent.com/105253684/200206363-78d29a6c-7046-41c9-83d7-0ad6c61c4e33.png)

* 컨텍스트 : 프로그래밍에서의 컨텍스트는 상황, 맥락, 문맥을 의미하며 개발자가 어떠한 작업을 완료하는 데 필요한 모든 관련 정보를 말합니다.

## 1-4 옵저버 패턴(Observer pattern)
주체가 어떤 객체(subject)의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버
목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴입니다.

![image](https://user-images.githubusercontent.com/105253684/200206758-8d9f018e-2564-4c48-9cc6-634112d3c685.png)

여기서 주체란 객체의 상태 변화를 보고 있는 관찰자이며, 옵저버들이란 이 객체의 상태 변화에 따라
전달되는 메서드 등을 기반으로 '추가 변화 사항'이 생기는 객체들을 의미합니다.

## 1-5 프록시 패턴(Proxy pattern)
프록시(proxy)란 '대리인'을 말하며 대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체
앞단의 인터페이스 역할을 하는 디자인 패턴입니다.

![image](https://user-images.githubusercontent.com/105253684/200207304-36dba7bb-9764-4ff2-83c4-320d91e4ada6.png)

이를 통해 객체의 속성, 변환 등을 보완하며 보안, 데이터 검증, 캐싱, 로깅에 사용합니다.

## 1-6 이터레이터 패턴(Iterator pattern)
이터레이터를 사용하여 컬렉션의 요소들에 접근하는 디자인패턴입니다.
이를 통해 순회할 수 있는 여러 가지 자료형의 구조와는 상관없이 이터레이터라는 하나의 인터페이스로
순회가 가능합니다.

![image](https://user-images.githubusercontent.com/105253684/200210802-fd6cb782-0747-45a1-8f00-3682e5c12c26.png)

## 1-7 MVC 패턴(Model-View-Controller)
모델(Model), 뷰(View), 컨트롤러(Controller)로 이루어진 디자인 패턴입니다. 애플리케이션의 구성
요소를 세 가지 역할로 구분하여 개발 프로세스에서 각각의 구성 요소에만 집중해서 개발할 수 있습니다.
재사용성과 확장성이 용이하다는 장점이 있고, 애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡해지는
단점이 있습니다.

![image](https://user-images.githubusercontent.com/105253684/200211860-17cdc37c-7900-4927-8e5b-af6f2b1e9560.png)

## 1-7-1 모델(Model)
애플리케이션의 데이터인 데이터베이스, 상수, 변수 등을 뜻합니다.

## 1-7-2 뷰(View)
사용자 인터페이스 요소를 나타냅니다. 즉, 모델을 기반으로 사용자가 볼 수 있는 화면을 뜻합니다.

## 1-7-3 컨트롤러(Controller)
하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할을 하며 이벤트 등 메인 로직을 담당합니다.
또한, 모델과 뷰의 생명주기도 관리하며, 모델이나 뷰의 변경 통지를 받으면 이를 해석하여 각각의
구성 요소에 해당 내용에 대해 알려줍니다.

## 1-8 MVP 패턴(Model-View-Presenter)
MVC 패턴으로부터 파생되었으며 MVC에서 C에 해당하는 컨트롤러가 프레젠터(Presenter)로 교체된 패턴입니다.

뷰와 프레젠터는 일대일 관계이기 때문에 MVC패턴보다 더 강한 결합을 지닌 디자인 패턴이라고 볼 수 있습니다.

## 1-9 MVVM 패턴(Model-View-View Model)
MVC의 C에 해당하는 컨트롤러가 뷰모델(View Model)로 바뀐 패턴입니다.

![image](https://user-images.githubusercontent.com/105253684/200212217-0dbd7bde-b057-4d48-b2c7-db02c93cc08f.png)

뷰모델은 뷰를 더 추상화한 계층이며, MVVM 패턴은 MVC 패턴과는 다르게 커맨드와 데이터 바인딩을 가지는
것이 특징입니다. 뷰와 뷰모델 사이의 양방향 데이터 바인딩을 지원하며 UI를 별도의 코드 수정 없이
재사용할 수 있고 단위 테스팅하기 쉽다는 장점이 있습니다.

* 커맨드 : 여러 가지 요소에 대한 처리를 하나의 액션으로 처리할 수 있게 하는 기법
* 데이터 바인딩 : 화면에 보이는 데이터와 웹 브라우저의 메모리 데이터를 일치시키는 기법으로, 뷰모델을 변경하면 뷰가 변경된다.

</pre>
</details>


<details>
  <summary>2022-11-04 (프로그래밍 패러다임)</summary>
<pre>

# 1. 프로그래밍 패러다임(Programming paradigm)
프로그래머에게 프로그래밍의 관점을 갖게 해주는 역할을 하는 개발 방법론입니다.

예를 들어 객체지향 프로그래밍은 프로그래머들이 프로그램을 상호 작용하는 객체들의 집합으로 볼 수 있게
하는 반면에, 함수형 프로그래밍은 상태 값을 지니지 않는 함수 값들의 연속으로 생각할 수 있게 해줍니다.

어떤 언어는 특정한 패러다임을 지원하기도 하는데, jdk 1.8 이전의 자바는 객체지향 프로그래밍을
지원하는 반면에, 하스켈은 함수형 프로그래밍을 지원합니다. 여러 패러다임을 지원하는 언어로는 
C++, 파이썬, 자바스크립트가 있으며 자바의 경우 jdk 1.8부터 함수형 프로그래밍 패러다임을 지원하기
위해 람다식, 생성자 레퍼런스, 메서드 레퍼런스를 도입했고 선언형 프로그래밍을 위해 스트림(stream)
같은 표준 API 등도 추가했습니다.

프로그래밍 패러다임은 크게 선언형, 명령형으로 나누며, 선언형은 함수형이라는 하위 집합을 갖습니다.
또한, 명령형은 다시 객체지향, 절차지향으로 나눕니다.

![image](https://user-images.githubusercontent.com/105253684/200223237-a39581a4-8b28-4b2b-b2cb-4070e9291089.png)

## 1-1 선언형과 함수형 프로그래밍
선언형 프로그래밍(declarative programming)이란 '무엇을'풀어내는가에 집중하는 패러다임이며,
"프로그램은 함수로 이루어진 것이다."라는 명제가 담겨 있는 패러다임이기도 합니다.

함수형 프로그래밍(functional programming)은 선언형 패러다임의 일종입니다. '순수 함수'들을
블록처럼 쌓아 로직을 구현하고 '고차 함수'를 통해 재사용성을 높인 프로그래밍 패러다임입니다.
* 순수 함수 : 출력이 입력에만 의존하는 것
* 고차 함수 : 함수가 함수를 값처럼 매개변수로 받아 로직을 생성할 수 있는 것

## 1-2 객체지향 프로그래밍(OOP, Object-Oriented Programming)
객체들의 집합으로 프로그램의 상호 작용을 표현하며 데이터를 객체로 취급하여 객체 내부에 선언된
메서드를 활용하는 방식을 말합니다. 설계에 많은 시간이 소요되며 처리 속도가 다른 프로그래밍
패러다임에 비해 상대적으로 느립니다.

### 1-2-1 객체지향 프로그래밍의 특징
객체지향 프로그래밍은 추상화, 캡슐화, 상속성, 다형성이라는 특징이 있습니다.
* 추상화(abstraction) : 복잡한 시스템으로부터 핵심적인 개념 또는 기능을 간추려내는 것을 의미
* 캡슐화(encapsulation) : 객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감추어 은닉하는 것
* 상속성(inheritance) : 상위 클래스의 특성을 하위 클래스가 이어받아서 재사용하거나 추가, 확장하는 것
* 다형성(polymorphism) : 하나의 메서드나 클래스가 다양한 방법으로 동작하는 것을 말하며, 대표적으로 오버로딩, 오버라이딩이 있음
  * 오버로딩 : 같은 이름을 가진 메서드를 여러 개 두는 것 - 메서드의 타입, 매개변수의 유형, 개수 등으로 여러 개를 두며 컴파일 중에 발생하는 '정적'다형성
  * 오버라이딩 : 메서드 오버라이딩을 말하며 상위 클래스로부터 상속받은 메서드를 하위 클래스가 재정의 하는 것 런타임 중 발생하는 '동적'다형성

### 1-2-2 객체지향 프로그래밍 설계 원칙
객체지향 프로그래밍을 설계할 때는 SOLID원칙을 지켜주어야 합니다.

* 단일 책임 원칙(SRP, Single Responsibility Principle) : 모든 클래스는 각각 하나의 책임만 가져야 하는 원칙
* 개방-페쇄 원칙(OCP, Open Closed Principle) : 유지 보수 사항이 생긴다면 코드를 쉽게 확장할 수 있도록 하고 수정할 때는 닫혀 있어야 하는 원칙
* 리스코프 치환 원칙(LSP, Liskov Substitution Principle) : 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 하는 것
* 인터페이스 분리 원칙(ISP, Interface Segregation Principle) : 하나의 일반적인 인터페이스보다 구체적인 여러 개의 인터페이스를 만들어야 하는 원칙

## 1-3 절차지향 프로그래밍
로직이 수행되어야 할 연속적인 계산 과정으로 이루어져 있고 일이 진행되는 방식으로 그저 코드를
구현하기만 하면 되기 때문에 가독성이 좋으며 실행 속도가 빠릅니다. 주로 계산이 많은 작업 등에
쓰입니다. 단점으로 모듈화하기가 어렵고 유지 보수성이 떨어진다는 점이 있습니다.

# 2. 패러다임의 혼합
어떠한 패러다임이 가장 좋냐고 묻는다면 답은 "그런 것은 없다." 입니다. 비즈니스 로직이나 서비스의
특징을 고려해서 패러다임을 정하는 것이 좋고, 하나의 패러다임을 기반으로 통일하여 서비스를 구축하는
것도 좋은 생각이지만 여러 패러다임을 조합해 상황과 맥락에 따라 패러다임 간의 장점만 취해 개발하는
것이 좋습니다.

</pre>
</details>