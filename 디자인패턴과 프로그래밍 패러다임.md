<details>
  <summary>2022-11-04 (디자인패턴)</summary>
<pre>

# 1. 디자인 패턴
프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의
'규약'형태로 만들어 놓은 것을 의미합니다.

## 1-1 싱글톤 패턴(Singleton pattern)
하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴입니다. 보통 데이터베이스 연결 모듈에 많이
사용합니다. 이처럼 동일한 자원이나 데이터를 처리하는 객체가 불필요하게 여러 개 만들어질 필요가
없는 경우에 주로 사용합니다.

![image](https://user-images.githubusercontent.com/105253684/200205493-333887ea-bdc2-453e-a0a5-1a1e65646208.png)

### 1-1-1 싱글톤 패턴의 단점
TDD(Test Driven Development)를 할 때 걸림돌이 됩니다. TDD를 할 때 단위 테스트를 주로 하는데,
단위 테스트는 테스트가 서로 독립적이어야 하며 테스트를 어떤 순서로든 실행할 수 있어야 합니다.

하지만 싱글톤 패턴은 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴이므로 각 테스트마다
'독립적인' 인스턴스를 만들기가 어렵습니다.

### 1-1-2 의존성 주입
싱글톤 패턴은 사용하기가 쉽고 굉장히 실용적이지만 모듈 간의 결합을 강하게 만들 수 있다는 단점이
있습니다. 이때 의존성 주입(DI, Dependency InJection)을 통해 모듈간의 결합을 조금 더 느슨하게
만들어 해결할 수 있습니다.

참고로 의존성이란 종속성이라고도 하며 A가 B에 의존성이 있다는 것은 B의 변경 사항에 대해 A또한
변해야 된다는 것을 의미합니다.

## 1-2 팩토리 패턴(Factory pattern)
객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴이자 상속 관계에 있는 두 클래스에서
상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는
패턴입니다.

![image](https://user-images.githubusercontent.com/105253684/200206347-c5d2248f-d3cb-496e-a0e9-836ff747e264.png)

## 1-3 전략 패턴(Strategy pattern)
정책 패턴(policy pattern)이라고도 하며, 객체의 행위를 바꾸고 싶은 경우 '직접' 수정하지 않고 전략
이라고 부르는 '캡슐화한 알고리즘'을 컨텍스트 안에서 바꿔주면서 상효 교체가 가능하게 만드는 패턴
입니다.

![image](https://user-images.githubusercontent.com/105253684/200206363-78d29a6c-7046-41c9-83d7-0ad6c61c4e33.png)

* 컨텍스트 : 프로그래밍에서의 컨텍스트는 상황, 맥락, 문맥을 의미하며 개발자가 어떠한 작업을 완료하는 데 필요한 모든 관련 정보를 말합니다.

## 1-4 옵저버 패턴(Observer pattern)
주체가 어떤 객체(subject)의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버
목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴입니다.

![image](https://user-images.githubusercontent.com/105253684/200206758-8d9f018e-2564-4c48-9cc6-634112d3c685.png)

여기서 주체란 객체의 상태 변화를 보고 있는 관찰자이며, 옵저버들이란 이 객체의 상태 변화에 따라
전달되는 메서드 등을 기반으로 '추가 변화 사항'이 생기는 객체들을 의미합니다.

## 1-5 프록시 패턴(Proxy pattern)
프록시(proxy)란 '대리인'을 말하며 대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체
앞단의 인터페이스 역할을 하는 디자인 패턴입니다.

![image](https://user-images.githubusercontent.com/105253684/200207304-36dba7bb-9764-4ff2-83c4-320d91e4ada6.png)

이를 통해 객체의 속성, 변환 등을 보완하며 보안, 데이터 검증, 캐싱, 로깅에 사용합니다.

## 1-6 이터레이터 패턴(Iterator pattern)
이터레이터를 사용하여 컬렉션의 요소들에 접근하는 디자인패턴입니다.
이를 통해 순회할 수 있는 여러 가지 자료형의 구조와는 상관없이 이터레이터라는 하나의 인터페이스로
순회가 가능합니다.

![image](https://user-images.githubusercontent.com/105253684/200210802-fd6cb782-0747-45a1-8f00-3682e5c12c26.png)

## 1-7 MVC 패턴(Model-View-Controller)
모델(Model), 뷰(View), 컨트롤러(Controller)로 이루어진 디자인 패턴입니다. 애플리케이션의 구성
요소를 세 가지 역할로 구분하여 개발 프로세스에서 각각의 구성 요소에만 집중해서 개발할 수 있습니다.
재사용성과 확장성이 용이하다는 장점이 있고, 애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡해지는
단점이 있습니다.

![image](https://user-images.githubusercontent.com/105253684/200211860-17cdc37c-7900-4927-8e5b-af6f2b1e9560.png)

## 1-7-1 모델(Model)
애플리케이션의 데이터인 데이터베이스, 상수, 변수 등을 뜻합니다.

## 1-7-2 뷰(View)
사용자 인터페이스 요소를 나타냅니다. 즉, 모델을 기반으로 사용자가 볼 수 있는 화면을 뜻합니다.

## 1-7-3 컨트롤러(Controller)
하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할을 하며 이벤트 등 메인 로직을 담당합니다.
또한, 모델과 뷰의 생명주기도 관리하며, 모델이나 뷰의 변경 통지를 받으면 이를 해석하여 각각의
구성 요소에 해당 내용에 대해 알려줍니다.

## 1-8 MVP 패턴(Model-View-Presenter)
MVC 패턴으로부터 파생되었으며 MVC에서 C에 해당하는 컨트롤러가 프레젠터(Presenter)로 교체된 패턴입니다.

뷰와 프레젠터는 일대일 관계이기 때문에 MVC패턴보다 더 강한 결합을 지닌 디자인 패턴이라고 볼 수 있습니다.

## 1-9 MVVM 패턴(Model-View-View Model)
MVC의 C에 해당하는 컨트롤러가 뷰모델(View Model)로 바뀐 패턴입니다.

![image](https://user-images.githubusercontent.com/105253684/200212217-0dbd7bde-b057-4d48-b2c7-db02c93cc08f.png)

뷰모델은 뷰를 더 추상화한 계층이며, MVVM 패턴은 MVC 패턴과는 다르게 커맨드와 데이터 바인딩을 가지는
것이 특징입니다. 뷰와 뷰모델 사이의 양방향 데이터 바인딩을 지원하며 UI를 별도의 코드 수정 없이
재사용할 수 있고 단위 테스팅하기 쉽다는 장점이 있습니다.

* 커맨드 : 여러 가지 요소에 대한 처리를 하나의 액션으로 처리할 수 있게 하는 기법
* 데이터 바인딩 : 화면에 보이는 데이터와 웹 브라우저의 메모리 데이터를 일치시키는 기법으로, 뷰모델을 변경하면 뷰가 변경된다.

</pre>
</details>


<details>
  <summary>2022-11-05 (프로그래밍 패러다임)</summary>
<pre>


</pre>
</details>